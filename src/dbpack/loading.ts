import {
  Connection,
  getConnection,
  BindParameters,
  ConnectionAttributes,
  Result,
} from 'oracledb';

interface SqlLoaderOptions {
  verbose: boolean;
}

export class SqlLoader {
  connectionOptions: ConnectionAttributes;
  tablename: string;
  options: SqlLoaderOptions;
  private _connection: Connection | false = false;
  private tableExists: boolean = false;

  private log(message: string, level: 'log' | 'warn' | 'error' = 'log') {
    if (this.options.verbose) {
      console[level](message);
    }
  }

  constructor(
    connectionString: string,
    password: string = 'password',
    user = 'system',
    tablename = 'mlemodules',
    opt?: Partial<SqlLoaderOptions>
  ) {
    this.connectionOptions = {
      connectionString,
      user,
      password,
    };
    this.tablename = tablename;
    this.options = { verbose: false, ...opt };
  }

  get connection() {
    if (this._connection) {
      return this._connection;
    }
    throw new Error('No connection established. Please call init first.');
  }

  async init(connection?: Connection) {
    if(!connection) {
      this._connection = await getConnection(this.connectionOptions)
    } else {
      console.log("Using established connection");
      this._connection = connection;
    } 
    //prettier-ignore
    const result = await this._connection.execute(`SELECT COUNT(TABLE_NAME) FROM USER_TABLES WHERE TABLE_NAME=:name`, [this.tablename.toUpperCase()]);
    this.tableExists = +result.rows! + [0][0] != 0;
    this.log(
      `Table ${this.tablename} does ${this.tableExists ? '' : 'not '}exist.`
    );
    if (!this.tableExists) {
      //prettier-ignore
      await this._connection.execute(`CREATE TABLE ${this.tablename}(module_id NUMBER GENERATED BY DEFAULT AS IDENTITY, name VARCHAR2(100) NOT NULL, created TIMESTAMP DEFAULT SYSDATE, author VARCHAR2(100) DEFAULT USER, types CLOB NOT NULL, source CLOB NOT NULL, PRIMARY KEY (module_id))`);
    }
    return this;
  }

  async execute(sql: string, bindings?: BindParameters) {
    if (this._connection) {
      let res: Result<string>;
      if (bindings) {
        res = await this._connection.execute(sql, bindings);
      } else {
        res = await this._connection.execute(sql);
      }
      await this._connection.commit();
      if (res.rowsAffected) {
        this.log(
          `Loaded ${res.rowsAffected} row${res.rowsAffected !== 0 && 's'}`
        );
      } else {
        this.log(`Completed call ${sql}`);
      }
    }
    return;
  }
}
